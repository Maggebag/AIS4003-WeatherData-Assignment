import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from typing import Dict

# Parameters

HURRICANE_THRESHOLD = 32.6 #m/s

def hurricane_events(df: pd.DataFrame, wind_col: str) -> pd.DataFrame:
    # Return empty DataFrame if input is empty
    if df.empty:
        return pd.DataFrame(columns=["year", "events"])

    # Select relevant columns, ensure datetime type, and sort by time
    d = df[["time", wind_col]].copy()
    d["time"] = pd.to_datetime(d["time"], utc=True)
    d = d.dropna(subset=[wind_col]).sort_values("time")

    # Set time as index and reindex to a complete daily range (missing days become NaN, breaking event runs)
    daily = d.set_index("time")[wind_col].asfreq("D")

    # Count hurricane events per year (an event starts when wind exceeds threshold after not being above)
    in_event = False
    counts: Dict[int, int] = {}
    for day, val in daily.items():
        above = pd.notna(val) and (float(val) > HURRICANE_THRESHOLD)
        if above and not in_event:
            counts[day.year] = counts.get(day.year, 0) + 1
            in_event = True
        elif not above:
            in_event = False

    # Return result as DataFrame
    if not counts:
        return pd.DataFrame(columns=["year", "events"])
    return pd.DataFrame(sorted(counts.items()), columns=["year", "events"])

def weekly_rainfall(df: pd.DataFrame, rain_col: str) -> pd.DataFrame:
    # Return empty DataFrame if input is empty
    if df.empty:
        return pd.DataFrame(columns=["time", "weekly_rain"])
    
    # Select relevant columns and ensure datetime type
    d = df[["time", rain_col]].copy()
    d["time"] = pd.to_datetime(d["time"], utc=True)

    # Set time as index, ensure daily frequency (fills missing days with NaN), then resample to weekly sums
    wk = d.set_index("time")[rain_col].asfreq("D").resample("W").sum(min_count=1)

    # Rename the result and reset index to return as DataFrame
    return wk.rename("weekly_rain").reset_index()

def monthly_temperature_statistics(
    dataframe: pd.DataFrame,
    target_month: int,
    mean_temperature_column: str,
    min_temperature_column: str, 
    max_temperature_column: str, 
    year_start: int = 2013,
    year_end: int = 2023,
) -> pd.DataFrame:

    if dataframe.empty or any(
        col not in dataframe.columns
        for col in [mean_temperature_column, min_temperature_column, max_temperature_column]
    ):
        return pd.DataFrame(
            columns=[
                "year",
                "monthly_mean",
                "monthly_std",
                "band_low",
                "band_high",
                "n_days",
            ]
        )

    # Select and prepare relevant columns
    df = dataframe[["time", mean_temperature_column, min_temperature_column, max_temperature_column]].copy()
    df["time"] = pd.to_datetime(df["time"], utc=True)
    df = df.dropna(subset=[mean_temperature_column])  # Require mean temperature, allow min/max to be NaN

    # Filter for the specified month and year range
    df = df[
        (df["time"].dt.month == target_month)
        & (df["time"].dt.year.between(year_start, year_end))
    ]
    if df.empty:
        return pd.DataFrame(
            columns=[
                "year",
                "monthly_mean",
                "monthly_std",
                "band_low",
                "band_high",
                "n_days",
            ]
        )

    df["year"] = df["time"].dt.year

    # Aggregate statistics per year
    aggregation = {
        mean_temperature_column: ["mean", "std", "count"],
        min_temperature_column: ["mean"],
        max_temperature_column: ["mean"],
    }
    grouped = df.groupby("year").agg(aggregation)

    # Flatten MultiIndex columns and rename
    grouped.columns = [
        "monthly_mean",
        "monthly_std",
        "n_days",
        "band_low",
        "band_high",
    ]
    grouped = grouped.reset_index()

    # Ensure numeric types for output columns
    for col in ["monthly_mean", "monthly_std", "band_low", "band_high"]:
        grouped[col] = pd.to_numeric(grouped[col], errors="coerce")

    return grouped

# Function to plot monthly temperature statistics with error bars and min/max band (Generated by ChatGPT)
def plot_monthly_temp_with_band(stats: pd.DataFrame, month: int, title_prefix="Average temperature"):
    if stats.empty:
        print("No data to plot.")
        return

    x = stats["year"].astype(int)
    y = stats["monthly_mean"].astype(float)
    yerr = stats["monthly_std"].astype(float)
    low = stats["band_low"].astype(float)
    high = stats["band_high"].astype(float)

    plt.figure(figsize=(20,5))
    # min/max envelope from daily min/max (averaged across the month)
    plt.fill_between(x, low, high, alpha=0.15, label="Mean daily min–max")
    # mean std from daily means
    plt.errorbar(x, y, yerr=yerr, fmt="o-", capsize=4, label="Monthly mean ±1σ")
    plt.title(f"{title_prefix} for month {month} ({x.min()}–{x.max()})")
    plt.xlabel("Year")
    plt.ylabel("°C")
    plt.grid(True, alpha=0.3)
    plt.legend()
    plt.tight_layout()
    plt.show()